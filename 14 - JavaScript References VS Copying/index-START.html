<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>JS Reference VS Copy</title>
  <link rel="icon" href="https://fav.farm/ğŸ”¥" />
</head>
<body>

  <script>
    // start with strings, numbers and booleans
    //å­—ä¸² , æ•¸å­— , å¸ƒæ—
    let a = 'A'
    let b = a

    a = 'B'
    console.log(a , b) // B , A

    let c = 0
    let d = c
    c++

    console.log(c , d) // 1 , 0

    let e = true
    let f = e
    // e = false
    e = !f

    console.log(e , f) // false , true

    let g = "A";
    let h = "A";
    let i = "A";
    h = "B", i = "C", g += h, g += i;
    console.log(g, h, i); //ABC , B ,C
    // Let's say we have an array
    const players = ['Wes', 'Sarah', 'Ryan', 'Poppy'];

    //æœƒä¿®æ”¹åˆ°è³‡æ–™æœ¬èº«
    // let playerTwo = players
    // playerTwo[0] = "jojo"

    // console.log(players , playerTwo);

    //ä¸æœƒä¿®æ”¹åˆ°è³‡æ–™,åˆ©ç”¨sliceå¯é”åˆ°è¤‡è£½,å› ç‚ºsliceæœƒé¡å¤–å†ç”¢ç”Ÿä¸€å€‹æ–°çš„é™£åˆ—
    let playerThree = players.slice()
    playerThree[0] = "jojo"

    console.log(playerThree , players)

    //è¢«ç”¨ä¾†åˆä½µå…©å€‹æˆ–å¤šå€‹é™£åˆ—ã€‚æ­¤æ–¹æ³•ä¸æœƒæ”¹è®Šç¾æœ‰çš„é™£åˆ—,æœƒå›å‚³å‘¼å«è€…é™£åˆ—æœ¬èº«,ä¹Ÿå°±æ˜¯èˆ‡playersçš„å€¼åˆä½µå¾Œçš„ç©ºé™£åˆ—ã€‚
    let playerFour = [].concat(players)
    playerFour[0] = "jojo"

    console.log(playerFour , players)

    //è§£æ§‹è³¦å€¼,å°‡playersè§£æ§‹å–å€¼,åœ¨åˆä½µè‡³player2,å›å‚³ä¸€å€‹æ–°çš„é™£åˆ—
    let playerFive = [...players]
    playerFive[0] = "jojo"

    console.log(playerFive , players)


    function createObj(name) {
      return {
        name
      };
    }

    let pr1 = createObj("johnny");
    let pr2 = createObj("lisa");
    let pr3 = createObj("iggy");

    let gr1 = [pr1, pr2, pr3];
    let gr2 = gr1.slice();
    // ç”±æ–¼gr2[0]å€¼ç‚ºpr1ï¼Œæ‰€ä»¥ä»–æœƒå»æ”¹è®Šgr2[0].nameï¼Œä¹Ÿå°±æ˜¯pr1çš„å€¼ï¼Œé‚£æˆ‘å†æ¬¡ç²å–gr1ï¼Œå®ƒè£¡é¢çš„pr1ä¹Ÿæœƒæ˜¯æ”¹è®Šå¾Œçš„å€¼ã€‚
    gr2[0].name = "momo";
    console.log(gr1, gr2); // (3) ["momo", "lisa", "iggy"] 

    // ä½†å¦‚æœæ”¹ç‚ºé€™æ¨£ï¼Œå¯ç™¼ç¾å…©è€…å·²äº’ä¸å½±éŸ¿ï¼Œå› ç‚ºè¨˜æ†¶é«”ç™¼ç¾æˆ‘å€‘çš„è¨˜æ†¶é«”ä¸­ä¸¦ç„¡momoé€™å€‹å€¼ï¼Œæ‰€ä»¥ä»–æœƒå‰µå»ºä¸€å€‹momoçš„å€¼ï¼Œä¸¦çµ¦äºˆä»–ä¸€å€‹è¨˜æ†¶é«”ç©ºé–“ï¼Œè€Œå¾Œæˆ‘å€‘gr2[0](ä¹Ÿå°±æ˜¯gr2çš„pr1)å°±æœƒæŒ‡å‘ä»–ï¼Œä¸¦ä¸å½±éŸ¿ã€‚
    gr2[0] = "momo";
    console.log(gr1, gr2); // (3) ["johnny", "lisa", "iggy"]  (3) ["momo", "lisa", "iggy"] 

    
    
    // and we want to make a copy of it.
    
    // You might think we can just do something like this:
    
    // however what happens when we update that array?
    
    // now here is the problem!
    
    // oh no - we have edited the original array too!
    
    // Why? It's because that is an array reference, not an array copy. They both point to the same array!
    
    // So, how do we fix this? We take a copy instead!
    
    // one way
    
    // or create a new array and concat the old one in
    
    // or use the new ES6 Spread
    
    // now when we update it, the original one isn't changed
    
    // The same thing goes for objects, let's say we have a person object
    
    // with Objects
    //æ¥ä¸‹ä¾†æ˜¯ç‰©ä»¶ä¹‹é–“çš„è¤‡è£½èˆ‡è³¦å€¼
    let someone = {
      name: 'Wes Bos',
      age: 80
    };
    let p1 = someone
    // æŸ¥çœ‹è¨˜æ†¶é«”ç„¡XXXå¾Œï¼Œå‰µå»ºä¸€å€‹XXXçš„å€¼ä¸¦è³¦äºˆè¨˜æ†¶é«”ç©ºé–“ï¼Œæ¥è‘—personåœ¨æŒ‡å‘ä»–ï¼Œè€Œèˆ‡p1äº’ä¸å½±éŸ¿ã€‚
    someone = "XXX"
    console.log(someone , p1)

    // å‰é¢æ­¥é©Ÿèˆ‡ä¸Šé¢ä¸€æ¨£ï¼Œä¸åŒçš„æ˜¯æœƒæ”¹è®Šperson.nameçš„å€¼ä¹Ÿå°±æ˜¯0x1çš„nameï¼Œå› æ­¤p1ä¹Ÿæœƒå—å½±éŸ¿ï¼Œå› ç‚ºp1æŒ‡å‘çš„ä¹Ÿæ˜¯personæ‰€æŒ‡å‘çš„0x1ã€‚
    someone.name = "XXX";
    console.log(someone, p1)


    let x = {
      name: "bogi",
      age: 87
    };
    let y = {
      name: "dandy"
    };
    let z = Object.assign(x, y)//Object.assign(x, y)å°‡yçš„nameå±¬æ€§è¤‡è£½åˆ°xä¸­ï¼Œä¸¦è¿”å›äº†ä¿®æ”¹å¾Œçš„xç‰©ä»¶ã€‚å› æ­¤ï¼Œzè®Šæ•¸è¢«è³¦å€¼ç‚ºxç‰©ä»¶

    console.log(z) // {name: "dandy", age: 87}


    let k = {
      name: "eva",
      age: 22,
      eat: function () {
        console.log("amazing")
      }
    };

    let kk = JSON.parse(JSON.stringify(k))
    console.log(kk)


    const wes = {
      name: 'Wes',
      age: 100,
      social: {
        twitter: '@wesbos',
        facebook: 'wesbos.developer'
      }
    };
    const dev = Object.assign({}, wes)

    // ç¬¬ä¸€é¡Œ
    // äº’ä¸å½±éŸ¿
    dev.social = null
    console.log(wes)// ä¸è®Š {twitter...}; 

    // ç¬¬äºŒé¡Œ
    dev.social.facebook = null
    console.log(wes.social) // {twitter:..., facebook:null}

    const dev3 = JSON.parse(JSON.stringify(wes))
    
    // and think we make a copy:

    // how do we take a copy instead?

    // We will hopefully soon see the object ...spread

    // Things to note - this is only 1 level deep - both for Arrays and Objects. lodash has a cloneDeep method, but you should think twice before using it.

  </script>

</body>
</html>
